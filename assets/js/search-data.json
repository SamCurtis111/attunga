{
  
    
        "post0": {
            "title": "Weather Data",
            "content": "Temperature Forecasts . Taken from BoM. Dashed line displays yesterdays forecast. Solid line is the most current BoM forecast . . . Forecast Precipitation . . .",
            "url": "https://samcurtis111.github.io/attunga/jupyter/2021/05/23/Weather-Data.html",
            "relUrl": "/jupyter/2021/05/23/Weather-Data.html",
            "date": " • May 23, 2021"
        }
        
    
  
    
        ,"post1": {
            "title": "SRA End of Day Position Report",
            "content": "Report Ran: 24-05-2021 14:00:38 . Section 1 - Current Qtr . 1.1 Attunga Holdings . Location Year Qtr Current Holding VWAP Current SRA Value (p. Unit) Total PnL . 0 NSWQLD | 2021 | Q2 | 54 | 211.17 | 53.13 | -8534.15 | . 1 NSWVIC | 2021 | Q2 | 30 | 873.81 | 1055.58 | 5453.15 | . 2 SAVIC | 2021 | Q2 | 30 | 4431.36 | 1238.38 | -95789.45 | . 3 VICNSW | 2021 | Q2 | 4 | 8004.00 | 5671.16 | -9331.36 | . 4 VICSA | 2021 | Q2 | 25 | 1763.20 | 2272.52 | 12732.95 | . . . Section 2 - Next Qtr . 2.1 Attunga Holdings . Location Year Qtr Current Holding VWAP . 0 NSWQLD | 2021 | Q3 | 32 | 252.75 | . 1 NSWVIC | 2021 | Q3 | 61 | 979.46 | . 2 SAVIC | 2021 | Q3 | 22 | 5246.73 | . 3 VICNSW | 2021 | Q3 | 10 | 4500.00 | . 4 VICSA | 2021 | Q3 | 20 | 2058.75 | . Tranche Settlement Prices . YEAR QTR TRANCHE NSWQLD QLDNSW SAVIC VICSA NSWVIC VICNSW . 0 2021 | Q3 | 01 | $502.00 | $10,228.20 | $9,568.80 | $2,760.00 | $2,208.00 | $5,918.40 | . 1 2021 | Q3 | 02 | $800.00 | $6,003.00 | $6,315.41 | $2,525.00 | $1,975.00 | $5,602.00 | . 2 2021 | Q3 | 03 | $800.00 | $7,729.00 | $6,315.41 | $2,272.50 | $1,656.00 | $5,681.66 | . 3 2021 | Q3 | 04 | $800.00 | $9,001.00 | $9,967.00 | $1,750.00 | $1,650.00 | $5,681.66 | . 4 2021 | Q3 | 05 | $800.00 | $11,542.00 | $9,967.00 | $1,662.50 | $1,650.00 | $6,200.00 | . 5 2021 | Q3 | 06 | $245.00 | $11,542.00 | $10,005.00 | $1,413.12 | $1,656.00 | $5,420.00 | . 6 2021 | Q3 | 07 | $200.00 | $11,772.84 | $10,205.10 | $1,550.00 | $993.60 | $7,500.00 | . 7 2021 | Q3 | 08 | $312.00 | $10,086.00 | $3,571.78 | $1,695.75 | $1,032.00 | $6,601.00 | . 8 2021 | Q3 | 09 | $252.00 | $12,950.12 | $4,504.00 | $1,600.94 | $1,304.00 | $4,500.00 | . 9 2021 | Q3 | 09 | $523.44 | $10,094.91 | $7,824.39 | $1,914.42 | $1,569.40 | $5,906.70 | . 10 2021 | Q3 | 10 | $254.00 | $12,302.50 | $5,250.00 | $1,601.00 | $1,389.00 | $5,625.00 | . Section 3 - Historical SRA Data . 3.1 Historical Payouts . Note: Need to change both the qtr &amp; product dropdowns to get the chart to update . 3.3 Attunga Holdings . all_holdings = df_holding.copy() all_holdings[&#39;yyyyqq&#39;] = all_holdings[&#39;yyyyqq&#39;].astype(int) all_holdings = all_holdings[all_holdings.yyyyqq &gt;= int(str(datetime.today().year) + &#39;0&#39; + current_qtr[-1])] all_holdings = all_holdings.sort_values(by=[&#39;yyyyqq&#39;,&#39;Location&#39;]).reset_index(drop=True) all_holdings . Location Year Qtr Current Holding VWAP yyyyqq . 0 NSWQLD | 2021 | Q2 | 54 | 211.17 | 202102 | . 1 NSWVIC | 2021 | Q2 | 30 | 873.81 | 202102 | . 2 SAVIC | 2021 | Q2 | 30 | 4431.36 | 202102 | . 3 VICNSW | 2021 | Q2 | 4 | 8004.00 | 202102 | . 4 VICSA | 2021 | Q2 | 25 | 1763.20 | 202102 | . 5 NSWQLD | 2021 | Q3 | 32 | 252.75 | 202103 | . 6 NSWVIC | 2021 | Q3 | 61 | 979.46 | 202103 | . 7 SAVIC | 2021 | Q3 | 22 | 5246.73 | 202103 | . 8 VICNSW | 2021 | Q3 | 10 | 4500.00 | 202103 | . 9 VICSA | 2021 | Q3 | 20 | 2058.75 | 202103 | . 10 NSWQLD | 2021 | Q4 | 74 | 795.49 | 202104 | . 11 NSWVIC | 2021 | Q4 | 102 | 1164.16 | 202104 | . 12 SAVIC | 2021 | Q4 | 40 | 5223.92 | 202104 | . 13 VICSA | 2021 | Q4 | 30 | 1994.84 | 202104 | . 14 NSWVIC | 2022 | Q1 | 10 | 4356.00 | 202201 | . 15 SAVIC | 2022 | Q1 | 40 | 5637.44 | 202201 | . 16 VICSA | 2022 | Q1 | 24 | 6148.76 | 202201 | . 17 NSWQLD | 2022 | Q2 | 30 | 337.03 | 202202 | . 18 NSWVIC | 2022 | Q2 | 30 | 826.29 | 202202 | . 19 SAVIC | 2022 | Q2 | 30 | 4022.22 | 202202 | . 20 NSWVIC | 2022 | Q3 | 70 | 854.48 | 202203 | . 21 SAVIC | 2022 | Q3 | 34 | 4834.21 | 202203 | . 22 VICSA | 2022 | Q3 | 20 | 2024.75 | 202203 | . 23 NSWQLD | 2022 | Q4 | 8 | 1254.00 | 202204 | . 24 NSWVIC | 2022 | Q4 | 60 | 772.71 | 202204 | . 25 SAVIC | 2022 | Q4 | 40 | 4988.63 | 202204 | . 26 VICSA | 2022 | Q4 | 10 | 2450.00 | 202204 | . 27 NSWVIC | 2023 | Q1 | 10 | 4320.00 | 202301 | . 28 SAVIC | 2023 | Q1 | 50 | 5665.24 | 202301 | . 29 VICSA | 2023 | Q1 | 20 | 6816.00 | 202301 | . 30 NSWQLD | 2023 | Q2 | 8 | 404.00 | 202302 | . 31 NSWVIC | 2023 | Q2 | 30 | 514.46 | 202302 | . 32 SAVIC | 2023 | Q2 | 30 | 3416.00 | 202302 | . 33 VICSA | 2023 | Q2 | 12 | 1743.17 | 202302 | . 34 NSWQLD | 2023 | Q3 | 10 | 257.00 | 202303 | . 35 NSWVIC | 2023 | Q3 | 90 | 637.55 | 202303 | . 36 SAVIC | 2023 | Q3 | 45 | 4022.38 | 202303 | . 37 VICSA | 2023 | Q3 | 20 | 1667.94 | 202303 | . 38 NSWQLD | 2023 | Q4 | 10 | 1501.00 | 202304 | . 39 NSWVIC | 2023 | Q4 | 60 | 725.17 | 202304 | . 40 SAVIC | 2023 | Q4 | 34 | 4084.00 | 202304 | . 41 VICSA | 2023 | Q4 | 20 | 1840.35 | 202304 | . 42 NSWVIC | 2024 | Q1 | 10 | 4368.00 | 202401 | . 43 SAVIC | 2024 | Q1 | 25 | 5154.00 | 202401 | . 44 VICSA | 2024 | Q1 | 10 | 6115.20 | 202401 | .",
            "url": "https://samcurtis111.github.io/attunga/jupyter/2021/05/23/SRA-Position.html",
            "relUrl": "/jupyter/2021/05/23/SRA-Position.html",
            "date": " • May 23, 2021"
        }
        
    
  
    
        ,"post2": {
            "title": "PASA",
            "content": "MTPASA . Total Availability . . . MTPASA Change . STPASA .",
            "url": "https://samcurtis111.github.io/attunga/jupyter/2021/05/23/PASA.html",
            "relUrl": "/jupyter/2021/05/23/PASA.html",
            "date": " • May 23, 2021"
        }
        
    
  
    
        ,"post3": {
            "title": "Option Deltas",
            "content": "from sqlalchemy import create_engine engine = create_engine(&#39;postgresql://postgres:iforgot23@localhost/BB_Data&#39;) import pandas as pd import numpy as np from tqdm import tqdm from calendar import monthrange import collections from datetime import datetime . product_dict = {&#39;NSW&#39;:&#39;W&#39;, &#39;QLD&#39;:&#39;Z&#39;, &#39;VIC&#39;:&#39;V&#39;,&#39;SA&#39;:&#39;U&#39;, 1:&#39;H&#39;, 2:&#39;M&#39;, 3:&#39;U&#39;, 4:&#39;Z&#39;, &#39;H&#39;:&#39;01&#39;,&#39;M&#39;:&#39;02&#39;,&#39;U&#39;:&#39;03&#39;,&#39;Z&#39;:&#39;04&#39;, 2016:&#39;16&#39;,2017:&#39;17&#39;,2018:&#39;18&#39;,2019:&#39;19&#39;,2020:&#39;20&#39;,2021:&#39;1&#39;,2022:&#39;2&#39;,2023:&#39;3&#39;,2024:&#39;4&#39;,2025:&#39;5&#39;, &#39;5&#39;:&#39;2015&#39;,&#39;6&#39;:&#39;2016&#39;,&#39;7&#39;:&#39;2017&#39;,&#39;8&#39;:&#39;2018&#39;,&#39;9&#39;:&#39;2019&#39;,&#39;0&#39;:&#39;2020&#39;,&#39;1&#39;:&#39;2021&#39;,&#39;2&#39;:&#39;2022&#39;,&#39;3&#39;:&#39;2023&#39;,&#39;4&#39;:&#39;2024&#39;, &#39;Call&#39;: &#39;C&#39;, &#39;Put&#39;:&#39;P&#39;, &#39;Q&#39;: &#39;E&#39;, &#39;Cal&#39;:&#39;H&#39;, &#39;Fin&#39;:&#39;H&#39;} strip_dict = {&#39;QLD&#39;:&#39;3&#39;, &#39;NSW&#39;:&#39;1&#39;, &#39;VIC&#39;:&#39;2&#39;, &#39;SA&#39;:&#39;4&#39;} qtr_months_dict = {&#39;Q1&#39;:[1,2,3], &#39;Q2&#39;:[4,5,6], &#39;Q3&#39;:[7,8,9], &#39;Q4&#39;:[10,11,12]} exp_map = {&#39;Cal&#39;:[&#39;Q1&#39;,&#39;Q2&#39;,&#39;Q3&#39;,&#39;Q4&#39;], &#39;Fin&#39;:[&#39;Q3&#39;,&#39;Q4&#39;,&#39;Q1&#39;,&#39;Q2&#39;]} . query = &#39;SELECT * FROM &quot;Option_Position &quot;&#39; options_df = pd.read_sql(query, engine) options_df = options_df.iloc[:,1:] options_df[&#39;Strike&#39;] = options_df[&#39;Strike&#39;].astype(int) # Partition df into qtr (or fin/cal) and year cols options_df[&#39;Year&#39;] = [int(d[-4:]) for d in options_df.Date] options_df[&#39;Exp Time&#39;] = [d[:-4] for d in options_df.Date] options_df[&#39;Exp Time&#39;] = options_df[&#39;Exp Time&#39;].str.replace(&#39; &#39;,&#39;&#39;) # remove whitespace # Convert each of the products to their BB code codes = [] for i in range(len(options_df)): if options_df[&#39;Exp Time&#39;][i]==&#39;Cal&#39;: prodtype = product_dict[options_df[&#39;Exp Time&#39;][i]] prodregion = strip_dict[options_df[&#39;Region&#39;][i]] prodq = &#39;Z&#39; elif options_df[&#39;Exp Time&#39;][i] == &#39;Fin&#39;: prodtype = product_dict[options_df[&#39;Exp Time&#39;][i]] prodregion = strip_dict[options_df[&#39;Region&#39;][i]] prodq = &#39;M&#39; else: prodtype = &#39;E&#39; prodregion = product_dict[options_df[&#39;Region&#39;][i]] prodq = product_dict[int(options_df.Date[i][1])] prodyear = product_dict[options_df.Year[i]] code = prodtype + prodregion + prodq + prodyear + product_dict[options_df[&#39;Type&#39;][i]] + &#39; &#39; + str(options_df[&#39;Strike&#39;][i]) + &#39; Comdty&#39; codes.append(code) options_df[&#39;BB_Code&#39;] = codes . query = &#39;SELECT * FROM &quot;Swap_Position &quot;&#39; swap_df = pd.read_sql(query, engine) swap_df = swap_df.iloc[:,1:] . def unique_times_func(subset_df): unique_times = zip(subset_df.Year, subset_df[&#39;Exp Time&#39;]) unique_times = list(set(unique_times)) # Convert fin / cal to their respective qtrs for x,y in unique_times: if y == &#39;Cal&#39;: for q in exp_map[y]: unique_times.append((x, q)) if y == &#39;Fin&#39;: for q in exp_map[y][0:2]: unique_times.append(((x-1), q)) for q in exp_map[y][2:]: unique_times.append((x, q)) # Remove fin / cal from list unique_times = [x for x in unique_times if &quot;Fin&quot; not in x] unique_times = [x for x in unique_times if &quot;Cal&quot; not in x] unique_times = list(set(unique_times)) return unique_times . option_dict = {} for state in options_df.Region.unique(): option_dict[state] = {} # Make a subset of df to filter into df sub_df = options_df[options_df.Region == state] state_times = unique_times_func(sub_df) # Make the qtrly frame subsets by state for dates in state_times: option_dict[state][dates] = {} # Initialise the empty cols to fill option_dict[state][dates][&#39;Description&#39;] = [] option_dict[state][dates][&#39;BB_Code&#39;] = [] option_dict[state][dates][&#39;Exp Time&#39;] = [] option_dict[state][dates][&#39;Quarter Hours&#39;] = [] option_dict[state][dates][&#39;Type&#39;] = [] option_dict[state][dates][&#39;Strike&#39;] = [] option_dict[state][dates][&#39;Cost&#39;] = [] option_dict[state][dates][&#39;Current Underlying&#39;] = [] option_dict[state][dates][&#39;Qty&#39;] = [] option_dict[state][dates][&#39;Option Type&#39;] = [] option_dict[state][dates][&#39;Current Price&#39;] = [] option_dict[state][dates][&#39;Current Vol&#39;] = [] option_dict[state][dates][&#39;Current Delta&#39;] = [] . field_list = [&#39;Description&#39;,&#39;BB_Code&#39;,&#39;Exp Time&#39;,&#39;Type&#39;,&#39;Strike&#39;,&#39;Cost&#39;,&#39;Qty&#39;] for i in range(len(options_df)): state = options_df.Region[i] yr = options_df.Year[i] #sub_df = options_df[options_df.Region==state] #unique_times = unique_times_func(sub_df) if options_df[&#39;Exp Time&#39;][i] == &#39;Cal&#39;: datelist = [] for q in exp_map[&#39;Cal&#39;]: datelist.append((yr, q)) for dates in datelist: for field in field_list: option_dict[state][dates][field].append(options_df[field][i]) elif options_df[&#39;Exp Time&#39;][i] == &#39;Fin&#39;: datelist = [] for q in exp_map[&#39;Fin&#39;][0:2]: datelist.append((yr-1, q)) for q in exp_map[&#39;Fin&#39;][2:]: datelist.append((yr, q)) for dates in datelist: for field in field_list: option_dict[state][dates][field].append(options_df[field][i]) else: #dates = (yr, options_df[&#39;Exp Time&#39;][i]) #for field in field_list: # option_dict[state][dates][field].append(options_df[field][i]) datelist = [] datelist.append((int(yr), str(options_df[&#39;Exp Time&#39;][i]))) for dates in datelist: for field in field_list: option_dict[state][dates][field].append(options_df[field][i]) . query = &#39;SELECT * FROM &quot;Option_Greeks &quot;&#39; df_greeks = pd.read_sql(query, engine) df_greeks = df_greeks.iloc[:,1:] . df_greeks.head() . Description BB_Code Option Type Current Underlying Current Price Current Vol Current Delta Data Date . 0 NSW 50 Call | EWM1C 50 Comdty | European | 75.500000 | 25.51 | 46.702 | 0.997 | 2021-05-24 16:32:30.612885 | . 1 NSW 51 Call | EWU1C 51 Comdty | European | 53.410000 | 7.26 | 45.421 | 0.633 | 2021-05-24 16:32:30.612885 | . 2 NSW 51 Put | H1Z2P 51 Comdty | American | 54.990002 | 0.91 | 17.373 | -0.219 | 2021-05-24 16:32:30.612885 | . 3 NSW 55 Call | H1Z3C 55 Comdty | American | 56.750000 | 5.67 | 17.401 | 0.599 | 2021-05-24 16:32:30.612885 | . 4 NSW 57 Call | H1Z2C 57 Comdty | American | 54.990002 | 1.82 | 15.302 | 0.435 | 2021-05-24 16:32:30.612885 | . for state in list(option_dict): for qtrs in list(option_dict[state]): for bqnt_code in option_dict[state][qtrs][&#39;BB_Code&#39;]: current_type = df_greeks[df_greeks.BB_Code==bqnt_code][&#39;Option Type&#39;].values[0] option_dict[state][qtrs][&#39;Option Type&#39;].append(current_type) current_price = df_greeks[df_greeks.BB_Code==bqnt_code][&#39;Current Price&#39;].values[0] option_dict[state][qtrs][&#39;Current Price&#39;].append(current_price) current_vol = df_greeks[df_greeks.BB_Code==bqnt_code][&#39;Current Vol&#39;].values[0] option_dict[state][qtrs][&#39;Current Vol&#39;].append(current_vol) current_delta = df_greeks[df_greeks.BB_Code==bqnt_code][&#39;Current Delta&#39;].values[0] option_dict[state][qtrs][&#39;Current Delta&#39;].append(current_delta) current_underlying = df_greeks[df_greeks.BB_Code==bqnt_code][&#39;Current Underlying&#39;].values[0] option_dict[state][qtrs][&#39;Current Underlying&#39;].append(current_underlying) current_expiry = df_greeks[df_greeks.BB_Code==bqnt_code][&#39;Exp Time&#39;].values[0] option_dict[state][qtrs][&#39;Exp Time&#39;].append(current_expiry) #print(bqnt_code) . for state in list(option_dict.keys()): for dates in option_dict[state]: option_dict[state][dates] = pd.DataFrame.from_dict(option_dict[state][dates]) . ValueError Traceback (most recent call last) &lt;ipython-input-42-27ae04c239f6&gt; in &lt;module&gt; 2 for state in list(option_dict.keys()): 3 for dates in option_dict[state]: -&gt; 4 option_dict[state][dates] = pd.DataFrame.from_dict(option_dict[state][dates]) ~ AppData Roaming Python Python37 site-packages pandas core frame.py in from_dict(cls, data, orient, dtype, columns) 1371 raise ValueError(&#34;only recognize index or columns for orient&#34;) 1372 -&gt; 1373 return cls(data, index=index, columns=columns, dtype=dtype) 1374 1375 def to_numpy( ~ AppData Roaming Python Python37 site-packages pandas core frame.py in __init__(self, data, index, columns, dtype, copy) 527 528 elif isinstance(data, dict): --&gt; 529 mgr = init_dict(data, index, columns, dtype=dtype) 530 elif isinstance(data, ma.MaskedArray): 531 import numpy.ma.mrecords as mrecords ~ AppData Roaming Python Python37 site-packages pandas core internals construction.py in init_dict(data, index, columns, dtype) 285 arr if not is_datetime64tz_dtype(arr) else arr.copy() for arr in arrays 286 ] --&gt; 287 return arrays_to_mgr(arrays, data_names, index, columns, dtype=dtype) 288 289 ~ AppData Roaming Python Python37 site-packages pandas core internals construction.py in arrays_to_mgr(arrays, arr_names, index, columns, dtype, verify_integrity) 78 # figure out the index, if necessary 79 if index is None: &gt; 80 index = extract_index(arrays) 81 else: 82 index = ensure_index(index) ~ AppData Roaming Python Python37 site-packages pandas core internals construction.py in extract_index(data) 399 lengths = list(set(raw_lengths)) 400 if len(lengths) &gt; 1: --&gt; 401 raise ValueError(&#34;arrays must all be same length&#34;) 402 403 if have_dicts: ValueError: arrays must all be same length . Generate Plots . def new_delta_dict(option_dict): delta_dict = {} for state in list(option_dict.keys()): delta_dict[state] = {} for dates in option_dict[state]: delta_dict[state][dates] = {} sub_df = pd.DataFrame() option_dict[state][dates][&#39;Unique Options&#39;] = list(zip(option_dict[state][dates][&#39;Description&#39;], option_dict[state][dates][&#39;Cost&#39;])) # added this option_types = list(option_dict[state][dates][&#39;Option Type&#39;].unique()) for option_type in option_types: sub_df = option_dict[state][dates][option_dict[state][dates][&#39;Option Type&#39;] == option_type] sub_df = sub_df.reset_index(drop=True) # Generate a range of possible underlying prices price_range = np.arange(1, sub_df[&#39;Current Underlying&#39;][0]+30, 2) ## BUILD AND FILL DATAFRAME ## delta_dict[state][dates][option_type] = pd.DataFrame() delta_dict[state][dates][option_type][&#39;Underlying Price&#39;] = price_range # for i,prod in enumerate(sub_df.Description): for i,prod in enumerate(sub_df[&#39;Unique Options&#39;]): # Added this delta_dict[state][dates][option_type][prod] = 0 if &#39;Put&#39; in prod[0]: delta_dict[state][dates][option_type][prod] = black_delta_put(delta_dict[state][dates][option_type][&#39;Underlying Price&#39;], sub_df[&#39;Strike&#39;][i], 0.02, sub_df[&#39;Exp Time&#39;][i], (sub_df[&#39;Current Vol&#39;][i]/100)) delta_dict[state][dates][option_type][prod] *= sub_df[&#39;Qty&#39;][i] elif &#39;Call&#39; in prod[0]: delta_dict[state][dates][option_type][prod] = black_delta_call(delta_dict[state][dates][option_type][&#39;Underlying Price&#39;], sub_df[&#39;Strike&#39;][i], 0.02, sub_df[&#39;Exp Time&#39;][i], (sub_df[&#39;Current Vol&#39;][i]/100)) delta_dict[state][dates][option_type][prod] *= sub_df[&#39;Qty&#39;][i] else: print(&#39;Unrecognised Option Type (put/call)&#39;) # Add the swap delta: swap_delta = swap_delta_func(swap_df, state, dates) delta_dict[state][dates][option_type][&#39;Swap Delta&#39;] = swap_delta delta_dict[state][dates][option_type][&#39;Total&#39;] = delta_dict[state][dates][option_type].iloc[:,1:].sum(axis=1) delta_dict[state][dates][option_type] = delta_dict[state][dates][option_type].set_index(&#39;Underlying Price&#39;) return delta_dict . z = new_delta_dict(option_dict) . AttributeError Traceback (most recent call last) &lt;ipython-input-38-3c30ac511dfd&gt; in &lt;module&gt; -&gt; 1 z = new_delta_dict(option_dict) &lt;ipython-input-34-782cde72d612&gt; in new_delta_dict(option_dict) 10 11 option_dict[state][dates][&#39;Unique Options&#39;] = list(zip(option_dict[state][dates][&#39;Description&#39;], option_dict[state][dates][&#39;Cost&#39;])) # added this &gt; 12 option_types = list(option_dict[state][dates][&#39;Option Type&#39;].unique()) 13 for option_type in option_types: 14 sub_df = option_dict[state][dates][option_dict[state][dates][&#39;Option Type&#39;] == option_type] AttributeError: &#39;list&#39; object has no attribute &#39;unique&#39; . state=&#39;VIC&#39; dates=(2021,&#39;Q3&#39;) np.unique(option_dict[state][dates][&#39;Option Type&#39;]) . array([&#39;European&#39;], dtype=&#39;&lt;U8&#39;) . import plotly.graph_objects as go from plotly.subplots import make_subplots import plotly.express as px . def plot_generator(state, option_dict): deltas = new_delta_dict(option_dict) # generate a fresh delta dict for the respective region state_dict = deltas[state].copy() state_dict = collections.OrderedDict(sorted(state_dict.items())) state_dfs = total_dfs(state_dict) # get the count of total dataframes in dict (nested) state_plots = {} for dates in list(state_dict): for option_type in state_dict[dates]: plotname = str(dates[0]) + &#39; &#39; + str(dates[1]) + &#39; &#39; + option_type sub_df = state_dict[dates][option_type] ## Rename the tuples in the columns ## newcols = list(sub_df)[:-2] newcols = [&#39;{}_{}&#39;.format(x[0],x[1]) for x in newcols] keepcols = list(sub_df)[-2:] colnames = newcols + keepcols sub_df.columns = colnames # Generate the plot state_plots[plotname] = px.line(sub_df) # Generate the figures fig = make_subplots(rows = len(state_plots), cols=1, subplot_titles=list(state_plots)) for i, plotname in enumerate(list(state_plots)): for dat in state_plots[plotname].data: fig.add_trace((go.Scatter(x=dat[&#39;x&#39;], y=dat[&#39;y&#39;], name=dat[&#39;name&#39;])), row=i+1, col=1) # Obtain vline from underlying_dict vline_date = (int(plotname[:4]), str(plotname[5:7])) if &#39;American&#39; in plotname: vline_type = &#39;American&#39; elif &#39;European&#39; in plotname: vline_type = &#39;European&#39; else: print(&#39;Option Type Error&#39;) # Obtain underlying and add to figure fig.add_vline(x=underlying_dict[state][vline_date][vline_type], line_width=2, line_dash=&quot;dash&quot;, row=i+1, col=1) fig.layout.template=None fig.update_layout(height=(state_dfs*100), width=800, title=(&quot;{} Option Payoff Diagrams&quot;.format(state))) return fig.show() . plot_generator(&#39;VIC&#39;, option_dict) . AttributeError Traceback (most recent call last) &lt;ipython-input-35-a5b69ef7e537&gt; in &lt;module&gt; -&gt; 1 plot_generator(&#39;VIC&#39;, option_dict) &lt;ipython-input-31-eefc310660d8&gt; in plot_generator(state, option_dict) 1 def plot_generator(state, option_dict): -&gt; 2 deltas = new_delta_dict(option_dict) # generate a fresh delta dict for the respective region 3 4 state_dict = deltas[state].copy() 5 state_dict = collections.OrderedDict(sorted(state_dict.items())) &lt;ipython-input-34-782cde72d612&gt; in new_delta_dict(option_dict) 10 11 option_dict[state][dates][&#39;Unique Options&#39;] = list(zip(option_dict[state][dates][&#39;Description&#39;], option_dict[state][dates][&#39;Cost&#39;])) # added this &gt; 12 option_types = list(option_dict[state][dates][&#39;Option Type&#39;].unique()) 13 for option_type in option_types: 14 sub_df = option_dict[state][dates][option_dict[state][dates][&#39;Option Type&#39;] == option_type] AttributeError: &#39;list&#39; object has no attribute &#39;unique&#39; .",
            "url": "https://samcurtis111.github.io/attunga/2021/05/23/Option-Positions-(In-Progress).html",
            "relUrl": "/2021/05/23/Option-Positions-(In-Progress).html",
            "date": " • May 23, 2021"
        }
        
    
  
    
        ,"post4": {
            "title": "NEM Data",
            "content": "Last ran: 2021-05-24 18:48:44 . NEM Price Data . 180it [00:00, 25889.88it/s] . Averaged Daily Prices . Note that current day and 8 day ahead are partial days, do not use these figures for pricing / modelling Click on individual states in chart to add / remove them for closer inspection . REGIONID NSW1 QLD1 SA1 TAS1 VIC1 RUN_DATETIME INTERVAL_DATE 2021-05-24 83.38 87.72 50.96 43.63 37.01 2021/05/24 18:00:00 2021-05-25 1045.43 1043.48 14.64 30.93 15.98 2021/05/24 18:00:00 2021-05-26 199.11 246.41 873.24 17.39 866.62 2021/05/24 18:00:00 2021-05-27 280.71 275.51 661.86 26.22 612.56 2021/05/24 18:00:00 2021-05-28 2191.90 2071.45 1989.88 194.42 1967.78 2021/05/24 18:00:00 2021-05-29 1160.17 1142.24 1117.32 156.54 1063.90 2021/05/24 18:00:00 2021-05-30 1745.26 1875.27 1526.23 139.42 1535.34 2021/05/24 18:00:00 2021-05-31 3995.78 3922.15 3513.87 224.06 3544.75 2021/05/24 18:00:00 2021-06-01 132.83 126.41 124.33 118.71 117.29 2021/05/24 18:00:00 . . .",
            "url": "https://samcurtis111.github.io/attunga/jupyter/2021/05/23/NEM-Data.html",
            "relUrl": "/jupyter/2021/05/23/NEM-Data.html",
            "date": " • May 23, 2021"
        }
        
    
  
    
        ,"post5": {
            "title": "Morning Review",
            "content": "Rough Format . NEM Summary . Spot market summary: . Yest spot prices | PD 7 Day spoot prices | Average 7 day price table (incl. caps) | . | Supply / Demand / Reserve . IC flows / constraints | . | Generation . Fuel mix | By DUID - outages / trips | Bid stacks (some of these might not be worth the work) | . | . ASX Summary . Yesterday biggest movers | .",
            "url": "https://samcurtis111.github.io/attunga/2021/05/23/Daily-Summary-(In-Progress).html",
            "relUrl": "/2021/05/23/Daily-Summary-(In-Progress).html",
            "date": " • May 23, 2021"
        }
        
    
  
    
        ,"post6": {
            "title": "Annualised Volatilities Report",
            "content": "from pathlib import Path import numpy as np import pandas as pd pd.set_option(&#39;display.max_rows&#39;, None) # prevent dfs from being truncated . data_path = Path(&quot;C:/Users/SamCurtis/AppData/Local/bipy/28095931/projects/02f1bf62483a4d82b93898b71672e018&quot;) / (&quot;tableau_vols.xlsx&quot;) raw_baseload = pd.read_excel(data_path, sheet_name=&#39;Baseload&#39;) raw_caps = pd.read_excel(data_path, sheet_name=&#39;Caps&#39;) raw_strips = pd.read_excel(data_path, sheet_name=&#39;Strips&#39;) last_update_path = Path(&quot;C:/Users/SamCurtis/AppData/Local/bipy/28095931/projects/02f1bf62483a4d82b93898b71672e018&quot;) / (&quot;volatility_data.xlsx&quot;) last_updated = pd.read_excel(last_update_path, sheet_name=&#39;last_updated&#39;) last_updated = last_updated[&#39;updated&#39;][0] . print(&#39;Last Updated: &#39;, last_updated) . Last Updated: 2021-05-20 09:03:48 . Baseload Contracts . baseload_pivot = pd.pivot_table(raw_baseload, index=[&quot;state&quot;, &quot;year&quot;,&quot;quater&quot;]) baseload_pivot = baseload_pivot.iloc[:,1:] baseload_pivot . annual monthly qtrly weekly . state year quater . NSW 2021 2 0.2552 | 0.5989 | 0.4044 | 0.9698 | . 3 0.1922 | 0.2017 | 0.2093 | 0.2634 | . 4 0.1912 | 0.1745 | 0.2011 | 0.2648 | . 2022 1 0.1892 | 0.1353 | 0.2485 | 0.1762 | . 2 0.1647 | 0.1246 | 0.1786 | 0.1363 | . 3 0.1530 | 0.1558 | 0.1548 | 0.2266 | . 4 0.1594 | 0.1518 | 0.1907 | 0.1432 | . 2023 1 0.1658 | 0.1659 | 0.2371 | 0.1413 | . 2 0.1803 | 0.1218 | 0.1672 | 0.0802 | . 3 0.1802 | 0.1080 | 0.1749 | 0.1097 | . 4 0.1608 | 0.1113 | 0.1710 | 0.1105 | . 2024 1 NaN | 0.1076 | 0.1761 | 0.1130 | . 2 NaN | 0.0985 | 0.1462 | 0.1081 | . 3 NaN | 0.1150 | 0.0828 | 0.0000 | . 4 NaN | 0.1147 | 0.0798 | 0.0000 | . 2025 1 NaN | 0.1755 | NaN | 0.2976 | . 2 NaN | 0.0755 | NaN | 0.0000 | . QLD 2021 2 0.2449 | 0.4478 | 0.3370 | 0.5460 | . 3 0.2051 | 0.2559 | 0.2159 | 0.3029 | . 4 0.1953 | 0.1773 | 0.1850 | 0.1746 | . 2022 1 0.1637 | 0.1407 | 0.1968 | 0.1565 | . 2 0.1624 | 0.2062 | 0.1968 | 0.2104 | . 3 0.1522 | 0.1404 | 0.1534 | 0.1318 | . 4 0.1597 | 0.1638 | 0.1828 | 0.2219 | . 2023 1 0.1547 | 0.1318 | 0.1956 | 0.0864 | . 2 0.1710 | 0.1176 | 0.1790 | 0.0806 | . 3 0.1621 | 0.1093 | 0.1684 | 0.0835 | . 4 0.2094 | 0.1093 | 0.1977 | 0.0848 | . 2024 1 NaN | 0.0953 | 0.1530 | 0.0528 | . 2 NaN | 0.0947 | 0.1335 | 0.0527 | . 3 NaN | 0.1750 | 0.1562 | 0.0374 | . 4 NaN | 0.1902 | 0.1649 | 0.0362 | . 2025 1 NaN | 0.7129 | NaN | 0.0330 | . 2 NaN | 0.0967 | NaN | 0.0266 | . SA 2021 2 0.2834 | 0.6309 | 0.4460 | 0.7593 | . 3 0.1733 | 0.2384 | 0.2025 | 0.3662 | . 4 0.1703 | 0.1220 | 0.1744 | 0.1708 | . 2022 1 0.2036 | 0.2047 | 0.2502 | 0.2259 | . 2 0.1684 | 0.1623 | 0.1981 | 0.1154 | . 3 0.1778 | 0.1421 | 0.1695 | 0.0986 | . 4 0.1668 | 0.1421 | 0.1612 | 0.0396 | . 2023 1 0.2022 | 0.2124 | 0.2860 | 0.3722 | . 2 0.2480 | 0.0926 | 0.2339 | 0.1619 | . 3 0.2716 | 0.0104 | 0.1802 | 0.0219 | . 4 0.2312 | 0.0000 | 0.1800 | 0.0000 | . 2024 1 NaN | 0.1669 | 0.2360 | 0.0872 | . 2 NaN | 0.0019 | 0.3126 | 0.0041 | . 3 NaN | 0.0453 | 0.2037 | 0.0000 | . 4 NaN | 0.0452 | 0.3057 | 0.0000 | . 2025 1 NaN | 0.0984 | NaN | 0.0000 | . 2 NaN | 0.0452 | NaN | 0.0000 | . VIC 2021 2 0.3260 | 0.7207 | 0.5329 | 0.8880 | . 3 0.2274 | 0.2850 | 0.2826 | 0.2778 | . 4 0.2303 | 0.2410 | 0.2711 | 0.1847 | . 2022 1 0.2430 | 0.1722 | 0.3106 | 0.1514 | . 2 0.2375 | 0.2657 | 0.3317 | 0.1998 | . 3 0.2210 | 0.2476 | 0.2933 | 0.1434 | . 4 0.2479 | 0.2148 | 0.3729 | 0.1092 | . 2023 1 0.1956 | 0.1213 | 0.2945 | 0.1102 | . 2 0.1683 | 0.1148 | 0.2261 | 0.0703 | . 3 0.1886 | 0.1432 | 0.2454 | 0.0611 | . 4 0.1897 | 0.1513 | 0.2865 | 0.0735 | . 2024 1 NaN | 0.2208 | 0.2635 | 0.0570 | . 2 NaN | 0.2070 | 0.1910 | 0.0563 | . 3 NaN | 0.2997 | 0.2549 | 0.0565 | . 4 NaN | 0.2520 | 0.2262 | 0.0784 | . 2025 1 NaN | 0.4078 | NaN | 0.2791 | . 2 NaN | 0.2371 | NaN | 0.0000 | . Caps . cap_pivot = pd.pivot_table(raw_caps, index=[&quot;state&quot;, &quot;year&quot;,&quot;quater&quot;]) cap_pivot = cap_pivot.iloc[:,1:] cap_pivot . annual monthly qtrly weekly . state year quater . NSW 2021 2 1.1059 | 3.4643 | 2.1228 | 6.7866 | . 3 NaN | 0.8998 | 0.6220 | 1.4875 | . 4 NaN | 0.4226 | NaN | 0.7077 | . 2022 1 NaN | 0.3867 | NaN | 0.5178 | . 2 NaN | 0.3744 | NaN | 0.4456 | . 3 NaN | 0.2345 | NaN | 0.1956 | . 4 NaN | 0.4266 | NaN | 0.3313 | . 2023 1 NaN | 0.3541 | NaN | 0.5455 | . 2 NaN | 0.1587 | NaN | 0.0400 | . 3 NaN | 0.0134 | NaN | 0.0282 | . 4 NaN | 0.0378 | NaN | 0.0358 | . 2024 1 NaN | 0.3585 | NaN | 0.5050 | . 2 NaN | 0.0000 | NaN | 0.0000 | . 3 NaN | 0.0000 | NaN | 0.0000 | . 4 NaN | 0.0000 | NaN | 0.0000 | . 2025 1 NaN | 2.3025 | NaN | 0.0000 | . 2 NaN | 0.0000 | NaN | 0.0000 | . QLD 2021 2 0.9268 | 2.3711 | 1.6585 | 1.1215 | . 3 NaN | 1.1848 | 0.8941 | 1.3355 | . 4 NaN | 0.5563 | NaN | 0.6616 | . 2022 1 NaN | 0.4004 | NaN | 0.4838 | . 2 NaN | 0.3389 | NaN | 0.3872 | . 3 NaN | 0.3055 | NaN | 0.3872 | . 4 NaN | 0.3308 | NaN | 0.3556 | . 2023 1 NaN | 0.5161 | NaN | 0.4140 | . 2 NaN | 0.0750 | NaN | 0.0000 | . 3 NaN | 0.0750 | NaN | 0.0000 | . 4 NaN | 0.2199 | NaN | 0.0000 | . 2024 1 NaN | 0.5796 | NaN | 0.0000 | . 2 NaN | 0.0000 | NaN | 0.0000 | . 3 NaN | 0.0000 | NaN | 0.0000 | . 4 NaN | 0.0000 | NaN | 0.0000 | . 2025 1 NaN | 0.0000 | NaN | 0.0000 | . 2 NaN | 0.0000 | NaN | 0.0000 | . SA 2021 2 0.9060 | 2.8593 | 1.7670 | 5.3844 | . 3 NaN | 0.6386 | 0.6686 | 1.3389 | . 4 NaN | 0.8966 | NaN | 1.7261 | . 2022 1 NaN | 0.4630 | NaN | 0.8504 | . 2 NaN | 0.7080 | NaN | 1.2469 | . 3 NaN | 0.7080 | NaN | 1.2469 | . 4 NaN | 0.5874 | NaN | 1.2362 | . 2023 1 NaN | 0.3033 | NaN | 0.4946 | . 2 NaN | 0.0000 | NaN | 0.0000 | . 3 NaN | 0.0000 | NaN | 0.0000 | . 4 NaN | 0.0000 | NaN | 0.0000 | . 2024 1 NaN | 0.2705 | NaN | 0.4266 | . 2 NaN | 0.0000 | NaN | 0.0000 | . 3 NaN | 0.0000 | NaN | 0.0000 | . 4 NaN | 0.0000 | NaN | 0.0000 | . 2025 1 NaN | 0.0000 | NaN | 0.0000 | . 2 NaN | 0.0000 | NaN | 0.0000 | . VIC 2021 2 1.3735 | 4.5328 | 2.7155 | 6.0657 | . 3 NaN | 1.4416 | 0.9847 | 0.5927 | . 4 NaN | 0.4052 | NaN | 0.6032 | . 2022 1 NaN | 0.3267 | NaN | 0.3321 | . 2 NaN | 0.4961 | NaN | 0.8586 | . 3 NaN | 0.6012 | NaN | 0.2381 | . 4 NaN | 0.2093 | NaN | 0.2394 | . 2023 1 NaN | 0.2669 | NaN | 0.4699 | . 2 NaN | 0.3004 | NaN | 0.6322 | . 3 NaN | 0.3004 | NaN | 0.6322 | . 4 NaN | 0.0000 | NaN | 0.0000 | . 2024 1 NaN | 0.0000 | NaN | 0.0000 | . 2 NaN | 0.0000 | NaN | 0.0000 | . 3 NaN | 0.0000 | NaN | 0.0000 | . 4 NaN | 0.0000 | NaN | 0.0000 | . 2025 1 NaN | 0.0000 | NaN | 0.0000 | . 2 NaN | 0.0000 | NaN | 0.0000 | . Strips . strips_pivot = pd.pivot_table(raw_strips, index=[&quot;state&quot;, &quot;year&quot;,&quot;prod_type&quot;]) strips_pivot = strips_pivot.iloc[:,1:] strips_pivot . annual monthly qtrly quater weekly . state year prod_type . NSW 2022 Cal 0.1436 | 0.1418 | 0.1693 | 4 | 0.1429 | . Fin 0.1628 | 0.1599 | 0.1894 | 2 | 0.1883 | . 2023 Cal 0.1501 | 0.1215 | 0.1685 | 4 | 0.1074 | . Fin 0.1337 | 0.1402 | 0.1665 | 2 | 0.1422 | . 2024 Cal NaN | 0.1036 | 0.0988 | 4 | 0.0562 | . Fin NaN | 0.1179 | 0.1427 | 2 | 0.1055 | . 2025 Fin NaN | 0.0904 | NaN | 2 | 0.0797 | . QLD 2022 Cal 0.1422 | 0.1659 | 0.1677 | 4 | 0.1684 | . Fin 0.1604 | 0.1839 | 0.1796 | 2 | 0.1984 | . 2023 Cal 0.1537 | 0.1248 | 0.1778 | 4 | 0.0776 | . Fin 0.1400 | 0.1351 | 0.1645 | 2 | 0.1114 | . 2024 Cal NaN | 0.1305 | 0.1415 | 4 | 0.0391 | . Fin NaN | 0.0855 | 0.1408 | 2 | 0.0590 | . SA 2022 Cal 0.1459 | 0.1491 | 0.1758 | 4 | 0.1697 | . Fin 0.1387 | 0.1379 | 0.1703 | 2 | 0.1839 | . 2023 Cal 0.2033 | 0.0805 | 0.1972 | 4 | 0.1331 | . Fin 0.1487 | 0.1042 | 0.1817 | 2 | 0.1240 | . 2024 Cal NaN | 0.0565 | 0.2388 | 4 | 0.0286 | . Fin NaN | 0.0576 | 0.1962 | 2 | 0.0323 | . 2025 Fin NaN | 0.0499 | NaN | 2 | 0.0000 | . VIC 2022 Cal 0.2035 | 0.1890 | 0.2803 | 4 | 0.1238 | . Fin 0.2112 | 0.2140 | 0.2758 | 2 | 0.1810 | . 2023 Cal 0.1624 | 0.1021 | 0.2441 | 4 | 0.0720 | . Fin 0.1652 | 0.1248 | 0.2385 | 2 | 0.0939 | . 2024 Cal NaN | 0.1864 | 0.2022 | 4 | 0.0552 | . Fin NaN | 0.1608 | 0.2102 | 2 | 0.0471 | . 2025 Fin NaN | 0.2731 | NaN | 2 | 0.0912 | .",
            "url": "https://samcurtis111.github.io/attunga/jupyter/2021/05/23/Annualised-Volatilities.html",
            "relUrl": "/jupyter/2021/05/23/Annualised-Volatilities.html",
            "date": " • May 23, 2021"
        }
        
    
  
    
        ,"post7": {
            "title": "An Example Markdown Post",
            "content": "Example Markdown Post . Basic setup . Jekyll requires blog post files to be named according to the following format: . YEAR-MONTH-DAY-filename.md . Where YEAR is a four-digit number, MONTH and DAY are both two-digit numbers, and filename is whatever file name you choose, to remind yourself what this post is about. .md is the file extension for markdown files. . The first line of the file should start with a single hash character, then a space, then your title. This is how you create a “level 1 heading” in markdown. Then you can create level 2, 3, etc headings as you wish but repeating the hash character, such as you see in the line ## File names above. . Basic formatting . You can use italics, bold, code font text, and create links. Here’s a footnote 1. Here’s a horizontal rule: . . Lists . Here’s a list: . item 1 | item 2 | . And a numbered list: . item 1 | item 2 | Boxes and stuff . This is a quotation . . You can include alert boxes …and… . . You can include info boxes Images . . Code . You can format text and code per usual . General preformatted text: . # Do a thing do_thing() . Python code and output: . # Prints &#39;2&#39; print(1+1) . 2 . Formatting text as shell commands: . echo &quot;hello world&quot; ./some_script.sh --option &quot;value&quot; wget https://example.com/cat_photo1.png . Formatting text as YAML: . key: value - another_key: &quot;another value&quot; . Tables . Column 1 Column 2 . A thing | Another thing | . Tweetcards . Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 Footnotes . This is the footnote. &#8617; . |",
            "url": "https://samcurtis111.github.io/attunga/markdown/2020/01/14/test-markdown-post.html",
            "relUrl": "/markdown/2020/01/14/test-markdown-post.html",
            "date": " • Jan 14, 2020"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "This website is powered by fastpages 1. . a blogging platform that natively supports Jupyter notebooks in addition to other formats. &#8617; . |",
          "url": "https://samcurtis111.github.io/attunga/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://samcurtis111.github.io/attunga/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}